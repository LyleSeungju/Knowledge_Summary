Problem Check

### 요구 사항 정리

- ﻿﻿N개의 나무가 원형 배열 형태로 존재하며, 매 벌목 과정 마다 1만큼 자랍니다.
- ﻿﻿나무는 M이상이 되면 벌목이 될 수 있고, 나무의 높이만큼 구름이가 소지한 목재량이 늘어납니다.
- ﻿﻿구름이는 L, R, S 3개의 방법을 통해서 움직이고, 나무를 벌목합니다.
- ﻿﻿L 은 왼쪽으로 한 칸, R은 오른쪽으로 한 칸, S는 현재 위치에서 멈춥니다.
- ﻿﻿모든 명령이 수행된 후, 구름이가 소지한 목재량을 구하면 됩니다.

### 알고리즘 정리

• 기본적으로 시뮬레이션을 하는 문제입니다. 하지만, N^2의 풀이로는 풀리지 않기 때문에, 최적화가 필요한 문제입니다.

### Edge Case

- ﻿어떤 나무도 모두 캐지 못하는 경우
- ﻿﻿M = 0인 경우

### Problem Solving

주어진 N개의 나무 높이를 관리하는 변수와 Q개의 명령어를 관리하는 변수를 선언합니다.

현재 명령어에 따른 구름이의 위치와 최종 목재의 개수를 관리하는 변수를 선언하여 시뮬레이션 문제를 풀기 위한 준비를 완료합니다.

명령어를 순회하면서 현재 trees[cur_index]의 나무 높이를 확인하고 벌목할 수 있으면 벌목을 진행합니다. 벌목 후에는 trees[cur_index]를 0으로 설정합니다.

L, R 명령어를 수행하고 나무의 높이를 1씩 증가시키는 코드를 작성하면 간단하게 해결될 것처럼 보이지만, 이는 최적화가 필요한 시뮬레이션 문제이기 때문에 단순한 풀이는 틀렸습니다.

따라서 현재 진행된 명령어 개수에 따라 나무 높이가 달라지므로 이를 반영하여 아래와 같은 수식을 만들 수 있습니다.

s 번째 이동에서 1 번째 나무의 높이가 라면, 현재 나무의 높이는 j+ S 로 계산합니다. S 번째 이동에서 1 번째 나무가 벌목되었다고 가정하면, 나무 높이를 0으로 초기화하는 대신, 현재 나무 높이-S 만큼 뺍니다.

예를 들어, 높이가 3이었던 나무를 5번째 명령에서 벌목하면 높이는 3- 3+ 5) 로 변경됩니다. 그러면 나무의 높이는 -5 가 됩니다. 이후 10번째 명령, 즉 5번의 명령 이후에 다시 이 나무에 왔을 때, 5+ 10 이 되어 나무의 높이는 5가 됩니다. 따라서 인덱스로 처리할 수 있게 됩니다.

이 논리를 적용하면 문제를 어렵지 않게 해결할 수 있습니다

### Comment

시뮬레이션 문제를 접근할 때, 많이 착각을 하는 부분 중 하나가 바로 비효율적인 시뮬레이션을 해도 된다는 점입니다. 하지만 눈에 쉽게 구현하는 것도 좋지만 눈에 보이지 않는 부분을 최적화가 필요한 경우가 있습니다. 눈에 보이지 않는 최적화를 찾는 문제는 상당한 테크닉이 아닌 보통의 인덱스나 쉬운 수학으로 해결되는 부분이지만 이런 처리가 어렵습니다
