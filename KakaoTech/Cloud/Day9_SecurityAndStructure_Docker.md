#### 실습
0. nginx 이미지가 없다면 `docker pull nginx`
1. `docker image inspect nginx | jq '.[].RootFS'`
   -> 저장된 layerdb의 경로를 확인해본다
	```json
	"Type": "layers",
	"Layers": [
	  "sha256:a5290e2b0bfb2a71e247f493855ba693328f0282541cc1e26236184b035daae1",
	  "sha256:c9f3d91ef9c1cfc505fed2b692ba6da42d98f3c47aca60d3168725109dfb5ec6",
	  "sha256:d74e37852da1f272daccedcc81a5d806210cf465c807416ee9d8a1b35c160d10",
	  "sha256:9831f710e66b7254ae0ddb47f32cd65692e6c49a4473be229875f3365c40a481",
	  "sha256:a9922663af1a3447cf6d33cff814f5da9c7b1af040bb82efcabf111ebba04e48",
	  "sha256:6b313e736203a9531c1a26f6252554518deb3ff5483a3f99cc4e5ee140bbd44f",
	  "sha256:b2b830d00ce1dca5ff54a708e7450c3de97739476064d8f96f1f7602a4edc77d"
	]
	```
	- `"Type": "layers"` : 도커 이미지 파일 시스템 계층 구조 유형 - 레이어
		-  해당 도커는 이미지가 여러 레이어로 구성
	- `Layers: []` : 도커 이미지의 각 레이어에 대한 해시 목록을 포함
		- nginx 이미지는 여러 레이어로 구성되어 있으며, 각 레이어는 이전 레이어 위에 쌓임.

2. 아래의 경로에 layerdb에 저장된 폴더들을 확인해본다
	- `ls /var/lib/docker/image/overlay2/layerdb/sha256`
	- 이곳의 SHA256 해시는 각 레이어를 식별하는데 사용됨.
3. 확인된 cache-id를 /var/lib/docker/overlay2/ 경로에 접근하여 파일시스템 구조를 확인해본다
	- `sudo cat /var/lib/docker/image/overlay2/layerdb/sha256/<layer-hash>/cache-id` > 여기서 나온 값을 밑에 입력
	- `sudo ls /var/lib/docker/overlay2/<cache-id>/diff -al`
	- 일련의 명령어를 실행해보면 마지막에 나오는 폴더 구조가 nginx의 파일 시스템 구조라는 것을 확인할 수있다.
4. `docker run -it nginx /bin/bash` 에 접근하여 파일시스템에 생성된 파일들을 확인해본다.
	- .dockerenv, docker-entrypoint.d, docker-entrypoint.sh가 생성되었는데 이 파일들은 도커 컨테이너가 실행될때 생기는 것이다.
	
	알아본 결과
	- .dockerenv : 도커 컨테이너 내부에서만 존재하는 특수한 파일
		- 도커 데몬이 이 파일을 사용하여 현재 환경이 도커 내부인지 확인함(내부/외부인지 구별)
	- docker-entrypoint.d/ : 엔트리포인트 스크립트가 실행될 때 추가 스크립트나 설정 파일을 포함
		- 여러 초기화 스크립트나 설정 파일을 포함하여 컨테이너가 시작될때 수행됨
	- docker-entrypoint.sh: 컨테이너가 시작될때 실행되는 스크립트
		- 컨테이너가 시작될때 초기화 작업을 정의. ex 환경변수 설정, nginx 시작하는 명령어 등 


#### 루트 파일 구조
1. **/** **(루트 디렉토리)**
	• 모든 파일과 디렉토리의 최상위 디렉토리입니다. 모든 경로는 여기에서 시작합니다.
2. **/bin**
	• 기본 시스템 명령어들이 저장된 디렉토리입니다. 예를 들어, ls, cp, mv, rm 등의 명령어가 여기에 있습니다.
	• 부팅 과정에서 필요한 최소한의 명령어들이 포함되어 있습니다.
3. **/boot**
	• 부팅 로더와 커널 이미지가 저장된 디렉토리입니다.
	• 시스템이 부팅될 때 필요한 파일들이 여기에 있습니다. 예를 들어, vmlinuz (커널 이미지), initrd (초기 램 디스크 이미지) 등이 있습니다.
4. **/dev**
	• 시스템의 디바이스 파일이 저장된 디렉토리입니다.
	• 모든 하드웨어 디바이스는 이 디렉토리에 파일로 나타납니다. 예를 들어, sda1 (첫 번째 하드 디스크의 첫 번째 파티션), tty (터미널) 등이 있습니다.
5. **/etc**
	• 시스템의 설정 파일들이 저장된 디렉토리입니다.
	• 모든 시스템 전역 설정 파일이 여기에 있습니다. 예를 들어, passwd (사용자 정보), fstab (파일 시스템 마운트 정보) 등이 있습니다.
6. **/home**
	• 사용자들의 홈 디렉토리가 저장된 디렉토리입니다.
	• 각 사용자의 개인 파일과 설정 파일이 여기에 있습니다. 예를 들어, /home/username 디렉토리는 username 사용자의 홈 디렉토리입니다.
7. **/lib**
	• 시스템의 필수 라이브러리 파일들이 저장된 디렉토리입니다.
	• 커널 모듈과 기본 시스템 프로그램들이 사용하는 공유 라이브러리 파일이 여기에 있습니다.
8. **/media**
	• 이동식 미디어를 마운트하는 디렉토리입니다.
	• CD-ROM, USB 드라이브 등의 외부 장치를 마운트할 때 사용됩니다.
9. **/mnt**
	• 일시적으로 파일 시스템을 마운트하는 디렉토리입니다.
	• 시스템 관리자나 사용자가 파일 시스템을 임시로 마운트할 때 사용됩니다.
10. **/opt**
	• 선택적 소프트웨어 패키지가 설치되는 디렉토리입니다.
	• 주로 외부 애플리케이션이나 패키지를 설치할 때 사용됩니다.
11. **/proc**
	• 가상 파일 시스템으로, 시스템과 커널 프로세스 정보를 포함합니다.
	• 실행 중인 프로세스와 시스템 정보가 여기에 있습니다. 예를 들어, /proc/cpuinfo는 CPU 정보를 포함합니다.
12. **/root**
	• 루트 사용자의 홈 디렉토리입니다.
	• 일반 사용자의 홈 디렉토리와 비슷하지만, 시스템 관리자용입니다.
13. **/run**
	• 시스템의 최신 런타임 데이터가 저장되는 디렉토리입니다.
	• 시스템이 부팅된 이후 생성된 정보가 여기에 있습니다.
14. **/sbin**
	• 시스템 관리 명령어들이 저장된 디렉토리입니다.
	• 시스템 부팅, 복구, 복제에 필요한 명령어들이 포함됩니다. 예를 들어, shutdown, reboot, mkfs 등이 있습니다.
15. **/srv**
	• 시스템에서 제공하는 서비스와 관련된 데이터가 저장된 디렉토리입니다.
	• 예를 들어, 웹 서버에서 제공하는 파일이 여기에 있을 수 있습니다.
16. **/sys**
	• 가상 파일 시스템으로, 시스템 및 커널과 관련된 정보를 포함합니다.
	• 주로 하드웨어 정보와 관련된 파일이 여기에 있습니다.
17. **/tmp**
	• 일시적인 파일이 저장되는 디렉토리입니다.
	• 시스템과 사용자들이 일시적으로 사용하는 파일이 여기에 있습니다.
18. **/usr**
	• 사용자 프로그램과 데이터가 저장된 디렉토리입니다.
	• 시스템의 주요 프로그램들이 포함됩니다. 예를 들어, /usr/bin은 사용자 명령어들이, /usr/lib는 사용자 라이브러리가 저장됩니다.
19. **/var**
	• 가변 데이터 파일이 저장된 디렉토리입니다.
	• 로그 파일, 스풀 파일, 캐시 파일 등이 여기에 저장됩니다. 예를 들어, /var/log는 로그 파일이 저장됩니다.

#### 다른 실습
- `strace ls` : ls를 명령어를 쓰면 어떤 시스템콜이 사용되는지 추적
	- 디버깅과 성능 분석에 유용함 > eBPF에도 사용됨
- `strace -c ls`:  시스템 호출의 통계 정보를 요약하여 출력
- `capsh --print` : 리눅스의 프로세스 권한(capabilities)을 확인하고 설정
	- --print: 현재 프로세스의 권한 설정을 출력
- `docker run -it --pid=host --cap-add=SYS_PTRACE --security-opt apparmor=unconfined ubuntu /bin/bash`
	- `--pid=host` : 컨테이너가 호스트의 PID 네임스페이스를 공유 
	  -> 이것을 통해 컨테이너가 호스트의 모든 프로세스를 볼 수 있다.
	- `--cap-add=SYS_PTRACE`: 프로세스 트레이싱(이벤트 추적) 및 디버깅 허용 
	  -> 이것을 통해 `strace`명령어로 호스트 프로세스를 추적 할 수 있다. 
	- `--security-opt apparmor=unconfined`
		- apparmor 프로필을 비활성화 / apparmor은 리눅스 커널 보안 모듈: 프로그램 권한 해제
		- unconfined 옵션을 통해 해당 컨테이너는 보안 제약을 제거하여, 컨테이너가 더 많은 시스템 호출을 수행함.
	
	**이 명령어를 실행하면 컨테이너에서 할 수 있는 것**
	1. 호스트 프로세스 디버깅
	2. 호스트 시스템 모니터링 
	3. 보안 제약 해제
	 ->> 컨테이너를 통해서 호스트가 탈취될 수 있다.

#### tip
- `tail -f [filepath]` : 특정 파일의 마지막 몇 줄을 출력
	- `-n [number]`: 마지막 number 줄만큼 출력
	- `--retry`: 파일 접근 할 수 없을 때 자동으로 재시도
- `history` -> `!xxxx` : 이전에 쳤던 명령어 기록 -> 해당 번호로 빠르게 불러올 수 있음
