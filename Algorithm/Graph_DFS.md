#### DFS 깊이 우선 탐색 Depth First Search
: 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색하는 방법

![[Pasted image 20240618195455.png]]

1. 1,2,3,4,5,6,7,8,9,10,11,12 순서대로 탐색을 실시한다.
2. 1과 연결된 2,7,8 중 어느것을 가도 상관 없다
3. 2를 먼저 간다면? 2와 연결된 모든 것을 탐색 해본다. 1 > 2
	1. 3을 간다면? 2 > 3 > 4 or 2 > 3 > 5
	2. 6을 간다면 2 > 6
4. 7을 간다면?  1 > 7
5. 8을 간다면? 1 > 8
	1. 9를 간다면? 8 > 9 > 10 or 8 > 9 > 11
	2. 12를 간다면? 8 > 12

DFS의 시간 복잡도는 BFS와 마찬가지로 한 정점에서 연결된 모든 정점으로 이동 한다.
따라서 O(이동 가능한 정점의 개수) 시간 복잡도
- 재귀함수 사용 

Q. N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분 수열에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하시오. 
- 첫째 줄에 정수의 개수를 나타내는 N, 정수 S가 주어진다(1<= N <= 20, |S| <= 1,000,000)
- 둘째 줄에 정수가 빈 칸을 사이에 두고 주어진다.

위 코드를 구현하면
```js
function dfs(idx, sum){ 
	if (idx >= n) { //idx가 배열의 크기보다 크다면 재귀를 종료
		return; 
	} 
	sum += arr[idx]; // 부분 수열의 합계
	if (s === sum){
		answer += 1; 
	} 
	dfs(idx + 1, sum - arr[idx]); // 현재 노드를 제외하고 다음 노드를 탐색
	dfs(idx + 1, sum);  // 현재 노드를 포함하고 다음 노드를 탐색
}
```

주어진 데이터가 
```js
N = 5
S = 0
array = [-7, -3 -2, 5, 8]
```

1. -7를 선택한다? sum에 현재 -7을 더한다.
	- -3 선택
		- -2 or x
			- 5 or x
				- 8 or x
	- -3 선택x
		- -2 or x
			- 5 or x
				- 8 or x
2. -7를 선택하지않는다 sum에 더하지 않음.

위의 일련의 과정을 거치며 sum값이 목표 S값에 해당하는 경우 카운트 1증가하고 최종적으로
해당 카운트를 출력하게 되어 결과값은 1이다. `result: [-3,-2,5]`이다.

BFS 탐색과 달리 DFS 탐색은 비교적 코드가 간단한 편이지만 재귀함수를 이용하는 만큼 다른 유형의 코딩테스트 문제를 풀어 익숙해질 필요가 있다.
